slug: developing-with-quarkus-panache-reactive
id: gyon3t6zkpfs
title: Implementing a reactive application using Quarkus, Hibernate Reactive and Panache
description: |-
  In this track, you will get an introduction to reactive programming using [**Hibernate Reactive**](http://hibernate.org/reactive) with [**Panache**](https://quarkus.io/guides/hibernate-orm-panache).

  |What you need to know before you start|
  |----|
  |In order to get full benefit from taking this track you should...<br>• Have experience programming applications in Java using the [Maven](https://maven.apache.org/) framework.<br>• Have a working knowledge using Java annotations. <br>• Have hands on knowledge executing queries in a relational database. <br>• Have a general understanding of [Object Relational Mapping](https://en.wikipedia.org/wiki/Object%E2%80%93relational_mapping) (ORM). <br>• Have a basic familiarity with Quarkus as demonstrated in this [Getting Started](https://learn.openshift.com/middleware/courses/middleware-quarkus/getting-started) track.|

  Reactive systems have the following four characteristics. Reactive systems are:

  * Responsive - they must respond in a timely fashion
  * Elastic - they adapt themselves to the fluctuating load
  * Resilient - they handle failures gracefully
  * Asynchronous - the components of a reactive system interact using messages that are passed asynchronously

  Reactive programming puts asynchronous interactions at the forefront of information exchange. Unlike a typical request/response interaction which is synchronous in nature, making it so that control flow is blocked until a request is completed, in an asynchronous interaction, once a request is executed, control flow moves on to other tasks.

  The figure below illustrates the difference between synchronous and asynchronous information exchange in terms of a query-response interaction with a database.

  ![sync vs async](./assets/sync-vs-async.png)

  Under a reactive asynchronous interaction, there is no waiting around for a response to be returned. Rather, the program that executed the request  "listens" in the background for the response and processes data when the response is received. Many times the data will be received as a series of continuous messages delivered to the listener function intermittently.

  |What  is Non-Blocking I/O?|
  |----|
  |The asynchronous nature of reactive programming is also called **Non-Blocking I/O**.|

  # Working with Panache Reactive

  Hibernate is the de facto JPA implementation for object relational mapping ([ORM](https://en.wikipedia.org/wiki/Object%E2%80%93relational_mapping)). Panache Reactive allows Quarkus developers to have fully reactive, non-blocking access to relational databases that are represented by Hibernate.

  # What you'll be doing

  In this track you are going to apply reactive programming under Quarkus to the concepts and techniques covered previously in the track [**Effective data with Hibernate and Panache from Quarkus**](https://developers.redhat.com/courses/quarkus/panache). You are going to create a Quarkus application that supports the principles and characteristics that are fundamental to reactive systems.


  |LEARN MORE ABOUT REACTIVE SYSTEMS|
  |---|
  |To learn more about reactive systems read the [Reactive Manifesto](https://www.reactivemanifesto.org/).|

  |LEARN MORE ABOUT QUARKUS|
  |----|
  |You can learn more about Quarkus at [Quarkus.io](https://quarkus.io)|
icon: https://logodix.com/logo/1910931.png
level: intermediate
tags:
- openshift
owner: openshift
developers:
- doh@redhat.com
- bob@cogarttech.com
- nvinto@redhat.com
- ryanj@redhat.com
- cclyburn@redhat.com
sandbox_preset: openshift-411
lab_config:
  overlay: false
  width: 25
  position: right
checksum: "3214010280269239127"
