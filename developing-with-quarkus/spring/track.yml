slug: developing-with-quarkus-spring
id: r5623ypubfbf
type: track
title: Quarkus for Spring Boot Developers
description: |-
  This exercise demonstrates how Spring and Spring Boot developers can use well-known Spring annotations for Spring Data, Web, and Dependency Injection when building Quarkus applications. Spring developers can quickly become productive with Quarkus using existing knowledge and familiarity of these APIs.

  You'll build a relatively simple application that uses Spring Data to integrate (via JPA) with an underlying database, inject beans using Spring DI and expose them as RESTful endpoints via Spring Rest.

  ### Other possibilities

  Learn more at [quarkus.io](https://quarkus.io), or just drive on and get hands-on!
icon: https://logodix.com/logo/1910931.png
level: beginner
tags:
- openshift
owner: openshift
developers:
- btannous@redhat.com
- rjarvine@redhat.com
- nvinto@redhat.com
private: false
published: true
challenges:
- slug: 01-create-project
  id: dqmjucblbrsy
  type: challenge
  title: Step 1
  assignment: |-
    # Inspect Java runtime

    An appropriate Java runtime has been installed for you. Ensure you can use it by running this command:

    > If the command fails, wait a few moments and try again (it is installed in a background process and make take a few moments depending on system load).

    ```
    $JAVA_HOME/bin/java --version
    ```

    The command should report the version in use, for example (the versions and dates may be slightly different than the below example):

    ```console
    openjdk 11.0.10 2021-01-19
    OpenJDK Runtime Environment AdoptOpenJDK (build 11.0.10+9)
    OpenJDK 64-Bit Server VM AdoptOpenJDK (build 11.0.10+9, mixed mode)
    ```

    ## Create basic project

    Let's create the basic Quarkus _Hello World_ application and include the necessary spring extensions. Click this command to create the project:

    `cd /root/projects/quarkus &&
     mvn io.quarkus:quarkus-maven-plugin:2.0.0.Final:create \
        -DprojectGroupId=org.acme \
        -DprojectArtifactId=fruit-taster \
        -Dextensions="spring-data-jpa,spring-web,spring-di,jdbc-postgres, jdbc-h2"`{{execute T1}}

    This will use the Quarkus Maven Plugin and generate a basic Maven project for you in the `fruit-taster` subdirectory and include the following extensions to enable Spring annotations and APIs:

    * **spring-data-jpa** - Adds Spring Data annotations like `@CrudRepository` allowing integration with database-backed JPA repositories
    * **spring-web** - Adds Spring Web annotations like `@RestController`, `@RequestMapping`, `@PathVariable`, `@GetMapping`, etc
    * **spring-di** - Adds Spring DI annotations like `@Autowired`, `@Configuration`, `@Component`, etc
    * **jdbc-postgres** - Driver for Postgresql database. Note this is the `jdbc` variant. Reactive programmers may be interested in the [Reactive Postgres Client](https://quarkus.io/guides/reactive-postgres-client).
    * **jdbc-h2** - We also use the h2 database for local development

    ## Start the app

    First, switch to the directory in which the app was built:

    ```
    cd /root/projects/quarkus/fruit-taster
    ```

    Let's begin Live Coding. Click on the following command to start the app in _Live Coding_ mode:

    ```
    mvn quarkus:dev -Dquarkus.http.host=0.0.0.0
    ```

    You should see:

    ```console
    __  ____  __  _____   ___  __ ____  ______
     --/ __ \/ / / / _ | / _ \/ //_/ / / / __/
     -/ /_/ / /_/ / __ |/ , _/ ,< / /_/ /\ \
    --\___\_\____/_/ |_/_/|_/_/|_|\____/___/
    INFO  [io.quarkus] (Quarkus Main Thread) fruit-taster 1.0.0-SNAPSHOT on JVM (powered by Quarkus xx.xx.xx.Final) started in xxxs. Listening on: http://0.0.0.0:8080
    INFO  [io.quarkus] (Quarkus Main Thread) Profile dev activated. Live Coding activated.
    INFO  [io.quarkus] (Quarkus Main Thread) Installed features: [agroal, cdi, hibernate-orm, hibernate-orm-panache, jdbc-h2, jdbc-postgresql, narayana-jta, resteasy, resteasy-jackson, smallrye-context-propagation, spring-data-jpa, spring-di, spring-web]

    --
    Tests paused, press [r] to resume, [h] for more options>
    ```
    > The first time you build the app, new dependencies may be downloaded via maven. This should only happen once, after that things will go even faster.

    Test that the app is running by accessing the simple `hello` endpoint:

    `cd /root/projects/quarkus/fruit-taster && \
      curl http://localhost:8080/greeting`{{execute T2}}

    > You may need to click this command again in case it doesn't execute properly on first click

    you should see

    ```console
    Hello Spring
    ```

    This app doesn't use any Spring annotations yet. You'll _live code_ those in the next few steps while the app continues to run.
  tabs:
  - title: CLI
    type: terminal
    hostname: crc-nonest-1
  - title: OpenShift Web Console
    type: service
    hostname: crc-nonest-1
    port: 30443
  - title: Visual Editor
    type: code
    hostname: crc-nonest-1
    path: /root
  difficulty: basic
  timelimit: 150
- slug: 02-create-data
  id: iodpyq9gprmk
  type: challenge
  title: Step 2
  assignment: |-
    # Create Spring Data Repository

    The Spring Data repository abstraction simplifies dealing with data models by reducing the amount of boilerplate code required to implement data access layers for various persistence stores (such as JPA). `@Repository` and its sub-interfaces like `@CrudRepository` are the [central concept in Spring Data](https://docs.spring.io/spring-data/jpa/docs/current/reference/html/#repositories.core-concepts) which is a marker interface to provide data manipulation functionality for the entity class that is being managed. When the application starts, Quarkus configures the required persistence technologies and provides an implementation for the interfaces used.

    First, we need a data model.

    ## Create Model

    Click here to create and open a new file for our Remodelpository: `fruit-taster/src/main/java/org/acme/Fruit.java`.

    Click **Copy to Editor** to add the code:

    <pre class="file" data-filename="./fruit-taster/src/main/java/org/acme/Fruit.java" data-target="replace">
    package org.acme;

    import javax.persistence.Entity;
    import javax.persistence.GeneratedValue;
    import javax.persistence.Id;

    @Entity
    public class Fruit {

        @Id
        @GeneratedValue
        private Long id;

        private String name;

        private String color;


        public Fruit() {
        }

        public Fruit(String name, String color) {
            this.name = name;
            this.color = color;
        }

        public Long getId() {
            return id;
        }

        public void setId(Long id) {
            this.id = id;
        }

        public String getName() {
            return name;
        }

        public void setName(String name) {
            this.name = name;
        }

        public String getColor() {
            return color;
        }

        public void setColor(String color) {
            this.color = color;
        }
    }
    </pre>

    This is a simple POJO representing a Fruit, with a name and color.

    ## Create Spring Data Repository

    Next, click here to create and open a new file for our Repository: `fruit-taster/src/main/java/org/acme/FruitRepository.java`.

    Click **Copy to Editor** to create the code for the repository:

    <pre class="file" data-filename="./fruit-taster/src/main/java/org/acme/FruitRepository.java" data-target="replace">
    package org.acme;

    import org.springframework.data.repository.CrudRepository;

    import java.util.List;

    public interface FruitRepository extends CrudRepository&lt;Fruit, Long&gt; {

        List&lt;Fruit&gt; findByColor(String color);

    }
    </pre>

    Note that by extending Spring's `CrudRepository` interface you'll automatically get a complete set of methods to manipulate the entity (e.g. `count()`, `findAll()`, `delete()` and others).

    ## Create sample data

    Finally, we need some sample data to work with. Click here to create and open a new file to hold our sample data: `fruit-taster/src/main/resources/import.sql`.

    Click **Copy to Editor** to create add the sample data which will be used to populate our database when the app runs:

    <pre class="file" data-filename="./fruit-taster/src/main/resources/import.sql" data-target="replace">
    INSERT INTO fruit(id, name, color) VALUES (nextval('hibernate_sequence'), 'cherry', 'red');
    INSERT INTO fruit(id, name, color) VALUES (nextval('hibernate_sequence'), 'orange', 'orange');
    INSERT INTO fruit(id, name, color) VALUES (nextval('hibernate_sequence'), 'banana', 'yellow');
    INSERT INTO fruit(id, name, color) VALUES (nextval('hibernate_sequence'), 'avocado', 'green');
    INSERT INTO fruit(id, name, color) VALUES (nextval('hibernate_sequence'), 'strawberry', 'red');
    </pre>

    ## Configure Quarkus

    We need to configure our app to define database connection settings. Click: `fruit-taster/src/main/resources/application.properties` to open this file. This file contains Quarkus configuration.

    Click **Copy to Editor** to add the following values to the `application.properties` file:

    <pre class="file" data-filename="./fruit-taster/src/main/resources/application.properties" data-target="replace">
    quarkus.datasource.db-kind=h2
    quarkus.datasource.jdbc.url=jdbc:h2:mem:rest-crud
    quarkus.hibernate-orm.database.generation=drop-and-create
    quarkus.hibernate-orm.log.sql=true
    quarkus.hibernate-orm.sql-load-script=import.sql
    </pre>

    That’s it! Now you have a database, domain model (`Fruit`) and a repository (`FruitRepository`) to retrieve the domain model, and some sample data.

    > **NOTE**
    > Although we are using `import.sql` to initialize our database in our app, you shouldn't use this in production. Instead, review [suggested uses of Hibernate ORM in production](https://quarkus.io/guides/hibernate-orm#hibernate-orm-in-production-mode).

    Next, we'll create some injectable Spring Beans that will give us access to the data using the Spring DI annotations.
  tabs:
  - title: CLI
    type: terminal
    hostname: crc-nonest-1
  - title: OpenShift Web Console
    type: service
    hostname: crc-nonest-1
    port: 30443
  - title: Visual Editor
    type: code
    hostname: crc-nonest-1
    path: /root
  difficulty: basic
  timelimit: 150
- slug: 03-create-beans
  id: ckygqwg2wkym
  type: challenge
  title: Step 3
  assignment: |
    # Spring DI in Quarkus

    While you are encouraged to use CDI annotations for injection, Quarkus provides a compatibility layer for Spring dependency injection in the form of the `spring-di` extension.

    This step explains how your Quarkus application can leverage the well known Dependency Injection annotations included in the Spring Framework.

    Let’s proceed to create some beans using various Spring annotations.

    ## Create Functional Interface

    First we will create a `StringFunction` interface that some our beans will implement and which will be injected into another bean later on. This _Functional Interface_ provide target types for lambda expressions and method references we'll define.

    > Functional Interfaces are part of the base Java platform, and are not Spring-specific.

    Click here to create and open a new file for our interface: `fruit-taster/src/main/java/org/acme/StringFunction.java`.

    Click **Copy to Editor** to create the code for the interface:

    <pre class="file" data-filename="./fruit-taster/src/main/java/org/acme/StringFunction.java" data-target="replace">
    package org.acme;

    import java.util.function.Function;

    public interface StringFunction extends Function&lt;String, String&gt; {

    }
    </pre>

    With the interface in place, we will add an `AppConfiguration` class which will use the Spring’s Java Config style for defining a bean. It will be used to create a `StringFunction` bean that will capitalize the text passed as parameter.

    Click here to create and open a new file for our configuration: `fruit-taster/src/main/java/org/acme/AppConfiguration.java`.

    Click **Copy to Editor** to create the code for the interface:

    <pre class="file" data-filename="./fruit-taster/src/main/java/org/acme/AppConfiguration.java" data-target="replace">
    package org.acme;

    import org.springframework.context.annotation.Bean;
    import org.springframework.context.annotation.Configuration;

    @Configuration
    public class AppConfiguration {

        @Bean(name = "capitalizeFunction")
        public StringFunction capitalizer() {
            return String::toUpperCase;
        }
    }
    </pre>

    ## Create Functions

    Now we define another bean that will implement `StringFunction` using Spring’s _stereotype annotation_ style. This bean will effectively be a no-op bean that simply returns the input as is.

    Click here to create and open a new file for our bean: `fruit-taster/src/main/java/org/acme/NoOpSingleStringFunction.java`.

    Click **Copy to Editor** to create the code for the interface:

    <pre class="file" data-filename="./fruit-taster/src/main/java/org/acme/NoOpSingleStringFunction.java" data-target="replace">
    package org.acme;

    import org.springframework.stereotype.Component;

    @Component("noopFunction")
    public class NoOpSingleStringFunction implements StringFunction {

        @Override
        public String apply(String s) {
            return s;
        }
    }
    </pre>

    ## Add injectable configuration

    Quarkus also provides support for injecting configuration values using Spring’s `@Value` annotation. To see that in action, click **Copy to Editor** to add a new configuration parameter to our application which we'll use to add a little flavor to our app:

    <pre class="file" data-filename="./fruit-taster/src/main/resources/application.properties" data-target="append">
    taste.message = tastes great
    </pre>

    We'll also need a new Spring Bean to use this configuration! Click here to create and open a new file for our configuration: `fruit-taster/src/main/java/org/acme/MessageProducer.java`.

    Click **Copy to Editor** to create the code for the interface:

    <pre class="file" data-filename="./fruit-taster/src/main/java/org/acme/MessageProducer.java" data-target="replace">
    package org.acme;

    import org.springframework.beans.factory.annotation.Value;
    import org.springframework.stereotype.Service;

    @Service
    public class MessageProducer {

        @Value("${taste.message}")
        String message;

        public String getTaste() {
            return message;
        }
    }
    </pre>

    ## Tie them all together

    The final bean we will create ties together all the previous beans.

    Click here to create and open a new file for our configuration: `fruit-taster/src/main/java/org/acme/TasterBean.java`.

    Click **Copy to Editor** to create the code for the bean:

    <pre class="file" data-filename="./fruit-taster/src/main/java/org/acme/TasterBean.java" data-target="replace">
    package org.acme;

    import org.springframework.beans.factory.annotation.Autowired;
    import org.springframework.beans.factory.annotation.Qualifier;
    import org.springframework.beans.factory.annotation.Value;
    import org.springframework.stereotype.Component;

    @Component
    public class TasterBean {

        private final MessageProducer messageProducer;

        @Autowired
        @Qualifier("noopFunction")
        StringFunction noopStringFunction;

        @Autowired
        @Qualifier("capitalizeFunction")
        StringFunction capitalizerStringFunction;

        @Value("${taste.suffix:!}")
        String suffix;

        public TasterBean(MessageProducer messageProducer) {
            this.messageProducer = messageProducer;
        }

        public String taste(String fruitName) {
            final String initialValue = fruitName + ": " + messageProducer.getTaste() + " " + suffix;
            return noopStringFunction.andThen(capitalizerStringFunction).apply(initialValue);
        }
    }
    </pre>

    In the code above, we see that both field injection and constructor injection are being used (note that constructor injection does not need the `@Autowired` annotation since there is a single constructor). Furthermore, the `@Value` annotation on `suffix` has also a default value defined, which in this case will be used since we have not defined `taste.suffix` in `application.properties`.

    This new `TasterBean` has a method `taste()` which will report how each fruit tastes. It also uses our functions `noopStringFunction` and `capitalizerStringFunction` that we've injected via `@Autowired` to both do nothing and also transform the result INTO ALL CAPS.

    With our data model, repository, and accessor beans in place, let's move to the final step where we'll expose our fruits to the outside world via Spring Web annotations.
  tabs:
  - title: CLI
    type: terminal
    hostname: crc-nonest-1
  - title: OpenShift Web Console
    type: service
    hostname: crc-nonest-1
    port: 30443
  - title: Visual Editor
    type: code
    hostname: crc-nonest-1
    path: /root
  difficulty: basic
  timelimit: 150
- slug: 04-create-web
  id: ivfhhtevskhi
  type: challenge
  title: Step 4
  assignment: |+
    # Using Spring Web Annotations in Quarkus

    While you are encouraged to use JAX-RS annotation for defining REST endpoints, Quarkus provides a compatibility layer for Spring Web in the form of the `spring-web` extension.

    This step shows how your Quarkus application can leverage the well known Spring Web annotations to define RESTful services.

    ## Create Controllers

    Click here to create and open a new file for our basic controller for accessing Fruits: `fruit-taster/src/main/java/org/acme/FruitController.java`.

    Click **Copy to Editor** to create the code for the controller:

    <pre class="file" data-filename="./fruit-taster/src/main/java/org/acme/FruitController.java" data-target="replace">
    package org.acme;

    import java.util.List;
    import java.util.Optional;

    import org.springframework.web.bind.annotation.DeleteMapping;
    import org.springframework.web.bind.annotation.GetMapping;
    import org.springframework.web.bind.annotation.RequestMapping;
    import org.springframework.web.bind.annotation.RestController;
    import org.springframework.web.bind.annotation.PathVariable;
    import org.springframework.web.bind.annotation.PostMapping;
    import org.springframework.web.bind.annotation.PutMapping;

    @RestController
    @RequestMapping("/fruits")
    public class FruitController {

        private final FruitRepository fruitRepository;

        public FruitController(FruitRepository fruitRepository) {
            this.fruitRepository = fruitRepository;
        }

        @GetMapping(produces = "application/json")
        public Iterable&lt;Fruit&gt; findAll() {
            return fruitRepository.findAll();
        }


        @DeleteMapping("/{id}")
        public void delete(@PathVariable(name = "id") long id) {
            fruitRepository.deleteById(id);
        }

        @PostMapping(path = "/name/{name}/color/{color}", produces = "application/json")
        public Fruit create(@PathVariable(name = "name") String name, @PathVariable(name = "color") String color) {
            return fruitRepository.save(new Fruit(name, color));
        }

        @PutMapping(path = "/id/{id}/color/{color}", produces = "application/json")
        public Fruit changeColor(@PathVariable(name = "id") Long id, @PathVariable(name = "color") String color) {
            Optional&lt;Fruit&gt; optional = fruitRepository.findById(id);
            if (optional.isPresent()) {
                Fruit fruit = optional.get();
                fruit.setColor(color);
                return fruitRepository.save(fruit);
            }

            throw new IllegalArgumentException("No Fruit with id " + id + " exists");
        }

        @GetMapping(path = "/color/{color}", produces = "application/json")
        public List&lt;Fruit&gt; findByColor(@PathVariable(name = "color") String color) {
            return fruitRepository.findByColor(color);
        }
    }
    </pre>

    Notice the use of familiar Spring annotations like `@GetMapping` and `@PathVariable`. This exposes a set of RESTful APIs:

    * `GET /fruits` - Retrieve all Fruits as a JSON array
    * `DELETE /fruits/{id}` - Delete by ID
    * `POST /fruits/name/{name}/color/{color}` - create a new Fruit with a name and color
    * `PUT /fruits/id/{id}/color/{color}` - Update a fruit with a new color
    * `GET /fruits/color/{color}` - Retrieve all fruits of the specified color

    # Test app

    With this in place, we can now test our fruits access. The app is still running, so simply click the following commands to do a few operations:

    Get all fruits:

    `curl -s http://localhost:8080/fruits | jq`{{execute T2}}

    > Note you may need to click the command again, if it didn't execute in the new Terminal window.
    > **If you get a `parse error:`**, it is likely you missed an earlier step, and the Quarkus live reload caught it. Click on the [app's landing page](https://[[HOST_SUBDOMAIN]]-8080-[[KATACODA_HOST]].environments.katacoda.com)
    > to see details and clues about what may be wrong, and re-visit any prior steps to re-add the missing code.

    > Note that we pass the output to the `jq` utility which prints nicely-formatted JSON.

    You should see:

    ```json
    [
      {
        "color": "red",
        "id": 1,
        "name": "cherry"
      },
      {
        "color": "orange",
        "id": 2,
        "name": "orange"
      },
      {
        "color": "yellow",
        "id": 3,
        "name": "banana"
      },
      {
        "color": "green",
        "id": 4,
        "name": "avocado"
      },
      {
        "color": "red",
        "id": 5,
        "name": "strawberry"
      }
    ]
    ```

    Add a fruit:

    `curl -X POST -s http://localhost:8080/fruits/name/apple/color/red | jq`{{execute T2}}

    Get all `red` fruits:

    `curl -s http://localhost:8080/fruits/color/red | jq`{{execute T2}}

    Notice the presence of `apple` which we just added earlier.

    Change the color of the `apple` to `green`:

    `curl -X PUT -s http://localhost:8080/fruits/id/6/color/green | jq`{{execute T2}}

    And retrieve all green fruits:

    `curl -s curl -s http://localhost:8080/fruits/color/green | jq`{{execute T2}}

    You should see:

    ```json
    [
      {
        "color": "green",
        "id": 4,
        "name": "avocado"
      },
      {
        "color": "green",
        "id": 6,
        "name": "apple"
      }
    ]
    ```

    Indicating that the color of our `apple` has changed to `green`.

    ## Exercise Beans using Spring DI Annotations

    As a final test let's create another bean to use our injected beans and configuration using Spring DI annotations.

    Click here to create and open a new file for our taster controller for tasting Fruits: `fruit-taster/src/main/java/org/acme/TasterController.java`.

    Click **Copy to Editor** to create the code for the controller:

    <pre class="file" data-filename="./fruit-taster/src/main/java/org/acme/TasterController.java" data-target="replace">
    package org.acme;

    import java.util.ArrayList;
    import java.util.List;

    import org.springframework.web.bind.annotation.GetMapping;
    import org.springframework.web.bind.annotation.RequestMapping;
    import org.springframework.web.bind.annotation.RestController;

    import org.springframework.web.bind.annotation.PathVariable;

    @RestController
    @RequestMapping("/taster")
    public class TasterController {

        private final FruitRepository fruitRepository;

        private final TasterBean tasterBean;

        public TasterController(FruitRepository fruitRepository, TasterBean tasterBean) {
            this.fruitRepository = fruitRepository;
            this.tasterBean = tasterBean;
        }

        @GetMapping(produces = "application/json")
        public List&lt;TasteResult&gt; tasteAll() {
            List&lt;TasteResult&gt; result = new ArrayList<>();

            fruitRepository.findAll().forEach(fruit -> {
                result.add(new TasteResult(fruit, tasterBean.taste(fruit.getName())));
            });
            return result;
        }

        @GetMapping(path = "/{color}", produces = "application/json")
        public List&lt;TasteResult&gt; tasteByColor(@PathVariable(name = "color") String color) {
            List&lt;TasteResult&gt; result = new ArrayList<>();
            fruitRepository.findByColor(color).forEach(fruit -> {
                result.add(new TasteResult(fruit, tasterBean.taste(fruit.getName())));
            });
            return result;
        }

        public class TasteResult {
            public Fruit fruit;
            public String result;

            public TasteResult(Fruit fruit, String result) {
                this.fruit = fruit;
                this.result = result;
            }

        }
    }
    </pre>

    Again, we're using Spring Rest annotations like `@GetMapping` but we're also injecting our repository and taster bean in the constructor. This controller exposes 2 RESTful APIs:

    * `GET /taster` - taste all fruits and report result
    * `GET /taster/{color}` - Taste only fruits of the specified color

    App still running? Check. Let's test our new API:

    Taste all the fruits:

    `curl -s http://localhost:8080/taster | jq`{{execute T2}}

    You should see:

    ```json
    [
      {
        "fruit": {
          "color": "red",
          "id": 1,
          "name": "cherry"
        },
        "result": "CHERRY: TASTES GREAT !"
      },
      {
        "fruit": {
          "color": "orange",
          "id": 2,
          "name": "orange"
        },
        "result": "ORANGE: TASTES GREAT !"
      },
      {
        "fruit": {
          "color": "yellow",
          "id": 3,
          "name": "banana"
        },
        "result": "BANANA: TASTES GREAT !"
      },
      {
        "fruit": {
          "color": "green",
          "id": 4,
          "name": "avocado"
        },
        "result": "AVOCADO: TASTES GREAT !"
      },
      {
        "fruit": {
          "color": "red",
          "id": 5,
          "name": "strawberry"
        },
        "result": "STRAWBERRY: TASTES GREAT !"
      }
    ]
    ```
    Taste only the `green` fruits:

    `curl -s http://localhost:8080/taster/green | jq`{{execute T2}}

    ```
    [
      {
        "fruit": {
          "color": "green",
          "id": 4,
          "name": "avocado"
        },
        "result": "AVOCADO: TASTES GREAT !"
      }
    ]
    ```

    ## Add a suffix

    Click **Copy to Editor** to add a new suffix for our taster:

    <pre class="file" data-filename="./fruit-taster/src/main/resources/application.properties" data-target="append">
    taste.suffix = (if you like fruit!)
    </pre>

    And taste yellow fruits:

    `curl -s http://localhost:8080/taster/yellow | jq`{{execute T2}}

    You should see:

    ```json
    [
      {
        "fruit": {
          "color": "yellow",
          "id": 3,
          "name": "banana"
        },
        "result": "BANANA: TASTES GREAT (IF YOU LIKE FRUIT!)"
      }
    ]
    ```

    Notice the presence of our new suffix! Quarkus apps make it super easy to code, test, and re-code on the fly.

    ## Cleanup

    We're done coding, so let's stop the app. In the first Terminal, press `CTRL-C` to stop the running Quarkus app (or click the `clear`{{execute T1 interrupt}} command to do it for you).

  tabs:
  - title: CLI
    type: terminal
    hostname: crc-nonest-1
  - title: OpenShift Web Console
    type: service
    hostname: crc-nonest-1
    port: 30443
  - title: Visual Editor
    type: code
    hostname: crc-nonest-1
    path: /root
  difficulty: basic
  timelimit: 150
- slug: 05-build-app
  id: z1e8npxmemxn
  type: challenge
  title: Step 5
  assignment: |
    ## Build executable JAR

    Quarkus applications can be built as executable JARs, or native binary images. Here we'll use an executable JAR to deploy our app. Build the application:

    ```
    mvn clean package -DskipTests
    ```. It produces 2 jar files:

    * `target/fruit-taster-1.0.0-SNAPSHOT.jar` - containing just the classes and resources of the projects, it’s the regular artifact produced by the Maven build

    * `target/quarkus-app/quarkus-run.jar` - being an executable jar. Be aware that it’s not an über-jar as the dependencies are copied into several subdirectories (and would need to be included in any layered container image).

    See the files with this command:

    ```
    ls -l target/*.jar target/quarkus-app/*.jar
    ```

    > **NOTE**: Quarkus uses the _fast-jar_ packaging by default. The fast-jar packaging format is introduced as an alternative to the default jar packaging format. The main goal of this new format is to bring faster startup times.

    ## Run the executable JAR

    You can run the packaged application by clicking:

    ```
    java -jar target/quarkus-app/quarkus-run.jar
    ```

    Make sure the app is still working as expected (we'll use `curl` this time to access it directly):

    `curl -s http://localhost:8080/fruits | jq`{{execute T2}}

    ## Cleanup

    In the first Terminal, press `CTRL-C` to stop the running Quarkus native app (or click the `clear`{{execute T1 interrupt}} command to do it for you).

    ## Congratulations!

    You've now built a Java application as an executable JAR. Quarkus also supports building to _native_ images providing even greater startup speed and memory effeciency. Now let's give our app native powers by creating a Quarkus native app.
  tabs:
  - title: CLI
    type: terminal
    hostname: crc-nonest-1
  - title: OpenShift Web Console
    type: service
    hostname: crc-nonest-1
    port: 30443
  - title: Visual Editor
    type: code
    hostname: crc-nonest-1
    path: /root
  difficulty: basic
  timelimit: 150
- slug: 06-deploy-and-test
  id: elsi5ym3urbu
  type: challenge
  title: Step 6
  assignment: |-
    Now that we have our app built, let's move it into containers and into the cloud.

    ## Install OpenShift extension

    Quarkus offers the ability to automatically generate OpenShift resources based on sane default and user supplied configuration. The OpenShift extension is actually a wrapper extension that brings together the [kubernetes](https://quarkus.io/guides/deploying-to-kubernetes) and [container-image-s2i](https://quarkus.io/guides/container-image#s2i) extensions with defaults so that it’s easier for the user to get started with Quarkus on OpenShift.

    Run the following command to add it to our project:

    `mvn quarkus:add-extension -Dextensions="openshift"`{{execute T1}}

    ## Login to OpenShift

    We'll deploy our app as the `developer` user. Run the following command to login with the OpenShift CLI:

    `oc login -u developer -p developer`{{execute T1}}

    You should see

    ```
    Login successful.

    You don't have any projects. You can try to create a new project, by running

        oc new-project <projectname>
    ```

    ## Create project

    For this scenario, let's create a project that you will use to house your applications. Click:

    `oc new-project quarkus-spring --display-name="Sample Quarkus App using Spring APIs"`{{execute T1}}

    Before we deploy the application we need to deploy the Postgres database.

    ## Deploy Postgres

    When running in production, we'll need a Postgres database on OpenShift. Click the next command to deploy Postgres to your new project:

    `oc new-app \
        -e POSTGRESQL_USER=sa \
        -e POSTGRESQL_PASSWORD=sa \
        -e POSTGRESQL_DATABASE=fruits \
        -e POSTGRESQL_MAX_CONNECTIONS=200 \
        --name=postgres-database \
        openshift/postgresql`{{execute T1}}`

    ## Configure Quarkus

    Since we are now deploying this to Openshift our database will no longer be on localhost. And our production is running Postgres. How do we handle these multiple configurations? Quarkus has a neat feature where we can create different profiles. So we will use the %dev profile for our local environment.

    Click: `fruit-taster/src/main/resources/application.properties` to open this file. This file contains Quarkus configuration.

    Click **Copy to Editor** to add the following values to the `application.properties` file:

    <pre class="file" data-filename="./fruit-taster/src/main/resources/application.properties" data-target="replace">
    %dev.quarkus.datasource.db-kind=h2
    %dev.quarkus.datasource.jdbc.url=jdbc:h2:mem:rest-crud
    %dev.quarkus.hibernate-orm.database.generation=drop-and-create
    %dev.quarkus.hibernate-orm.log.sql=true

    # OpenShift Production Configuration
    quarkus.datasource.db-kind=postgresql
    quarkus.datasource.jdbc.url=jdbc:postgresql://postgres-database:5432/fruits
    quarkus.datasource.username=sa
    quarkus.datasource.password=sa
    quarkus.hibernate-orm.database.generation=drop-and-create
    quarkus.hibernate-orm.sql-load-script = import.sql

    taste.message = tastes great
    taste.suffix = (if you like fruit!)
    </pre>

    ## Deploy application to OpenShift

    Now let's deploy the application itself. Run the following command which will build and deploy the Quarkus app in Openshift:

    `mvn clean package \
    -Dquarkus.kubernetes-client.trust-certs=true \
    -Dquarkus.container-image.build=true \
    -Dquarkus.kubernetes.deploy=true \
    -Dquarkus.kubernetes.deployment-target=openshift \
    -Dquarkus.openshift.route.expose=true \
    -DskipTests`{{execute T1}}`

    The output should end with `BUILD SUCCESS`.

    For more details of the above options:

    * `quarkus.kubernetes-client.trust-certs=true` - We are using self-signed certs in this simple example, so this simply says to the extension to trust them.
    * `quarkus.container-image.build=true` - Instructs the extension to build a container image
    * `quarkus.kubernetes.deploy=true` - Instructs the extension to deploy to OpenShift after the container image is built
    * `quarkus.kubernetes.deployment-target=openshift` - Instructs the extension to generate and create the OpenShift resources (like `DeploymentConfig`s and `Service`s) after building the container
    * `quarkus.openshift.route.expose=true` - Instructs the extension to generate an OpenShift `Route` so we can access our application from outside the OpenShift cluster

    Finally, make sure it's actually done rolling out:

    `oc rollout status -w dc/fruit-taster`{{execute T1}}

    Wait (about 30 seconds) for that command to report `replication controller "fruit-taster-1" successfully rolled out` before continuing.

    > If the `oc rollout` command appears to not finish, just `CTRL-C` it and run it again.

    And now we can access using `curl` once again:

    `curl -s http://fruit-taster-quarkus-spring.[[HOST_SUBDOMAIN]]-80-[[KATACODA_HOST]].environments.katacoda.com/taster | jq`{{execute T1}}

    You should see the same fruits being tasted:

    ```console
    [
      {
        "fruit": {
          "color": "red",
          "id": 1,
          "name": "cherry"
        },
        "result": "CHERRY: TASTES GREAT (IF YOU LIKE FRUIT!)"
      },
      ...
    ```


    You can also see the app deployed in the [OpenShift Developer Toplogy](https://console-openshift-console-[[HOST_SUBDOMAIN]]-443-[[KATACODA_HOST]].environments.katacoda.com/topology/ns/quarkus-spring)


    ## Scale the app

    With that set, let's see how fast our app can scale up to 10 instances:

    `oc scale --replicas=10 dc/fruit-taster`{{execute T1}}

    Back in the [OpenShift Developer Toplogy](https://console-openshift-console-[[HOST_SUBDOMAIN]]-443-[[KATACODA_HOST]].environments.katacoda.com/topology/ns/quarkus-spring) you'll see the app scaling dynamically up to 10 pods:

    ![Scaling](/openshift/assets/middleware/quarkus/scaling_spring.png)

    We now have 10 instances running providing better performance. Make sure it still works:

    `curl -s http://fruit-taster-quarkus-spring.[[HOST_SUBDOMAIN]]-80-[[KATACODA_HOST]].environments.katacoda.com/taster | jq`{{execute T1}}

    **10 not enough? Try 50!** Click the command to scale this app to 50 instances:

    `oc scale --replicas=50 dc/fruit-taster`{{execute T1}}


    It will take a bit longer to scale that much. In the meantime the app continues to respond:

    `curl -s http://fruit-taster-quarkus-spring.[[HOST_SUBDOMAIN]]-80-[[KATACODA_HOST]].environments.katacoda.com/taster | jq`{{execute T1}}

    You can watch the 50 pods spinning up:

    `oc get pods -w -l app.kubernetes.io/name=fruit-taster`{{execute T1}}

    Watch as long as you like, then `CTRL-C` the pod watcher.

    Finally, scale it back down:

    `oc scale --replicas=1 dc/fruit-taster`{{execute T1}}

    # Open the solution in an IDE in the Cloud!
    Want to continue exploring this solution on your own in the cloud? You can use the free [Red Hat CodeReady Workspaces](https://developers.redhat.com/products/codeready-workspaces/overview) IDE running on the free [Red Hat Developer Sandbox](http://red.ht/dev-sandbox). [Click here](https://workspaces.openshift.com) to login or to register if you are a new user. This free service expires after 30 days, but you can always enable a new free 30-day subscription.

    Once logged in, [click here](https://workspaces.openshift.com/f?url=https://raw.githubusercontent.com/openshift-katacoda/rhoar-getting-started/solution/quarkus/spring/devfile.yaml) to open the solution for this project in the cloud IDE. While loading, if it asks you to update or install any plugins, you can say no.

    # Fork the source code to your own GitHub!
    Want to experiment more with the solution code you just worked with? If so, you can fork the repository containing the solution to your own GitHub repository by clicking on the following command to execute it:

    `/root/projects/forkrepo.sh`{{execute T1}}
    - Make sure to follow the prompts. An error saying `Failed opening a web browser at https://github.com/login/device exit status 127` is expected.
    - [Click here](https://github.com/login/device) to open a new browser tab to GitHub and paste in the code you were presented with and you copied.
    - Once done with the GitHub authorization in the browser, close the browser tab and return to the console and press `Enter` to complete the authentication process.
    - If asked to clone the fork, press `n` and then `Enter`.
    - If asked to confirm logout, press `y` and the `Enter`.

       > **NOTE:** This process uses the [GitHub CLI](https://cli.github.com) to authenticate with GitHub. The learn.openshift.com site is not requesting nor will have access to your GitHub credentials.

    After completing these steps the `rhoar-getting-started` repo will be forked in your own GitHub account. On the `solution` branch in the repo, the `spring` project inside the `quarkus` folder contains the completed solution for this scenario.

    ## Congratulations!

    This step covered the deployment of a Quarkus application on OpenShift using Spring compatibility APIs. To try out the native features, try the Getting Started tutorial. There is much more, and the integration with these environments has been tailored to make Quarkus applications execution very smooth.
  tabs:
  - title: CLI
    type: terminal
    hostname: crc-nonest-1
  - title: OpenShift Web Console
    type: service
    hostname: crc-nonest-1
    port: 30443
  - title: Visual Editor
    type: code
    hostname: crc-nonest-1
    path: /root
  difficulty: basic
  timelimit: 150
checksum: "3279382600858358074"
